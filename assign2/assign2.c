/*
Author: Andrew DiCarlo
Assignment Number: Assign2
File Name: assign2.c
Course/Section: CS 3733 - 002
Due Date: 11OCT2020
Instructor: Dr. Silvestro
*/

#include "pslibrary.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX(a, b) ((a) > (b) ? (a) : (b))

void printSchedOutput(char *s1, char *s2, char *alg);

int main(int argc, char *argv[])
{
    int i, q, x1, x2, y1, y2, z1, z2;
    int *argAdds[] = {&q, &x1, &y1, &z1, &x2, &y2, &z2};
    // Print usage message if the number of arguments is incorrect
    if (argc != 8) {
        printf("Wrong number of arguments.\nUsage: \n%s q x1 y1 z1 x2 y2 z2\n\n", argv[0]);
        printf("\tq stands for the quantum value\n");
        printf("\t(x1, y1, z1) correspond to a process with x1 units of CPU burst, y1 units of I/O burst, then z1 more "
               "units of CPU "
               "burst\n");
        printf("\t(x2, y2, z2) correspond to a process with x2 units of CPU burst, y2 units of I/O burst, then z2 more "
               "units of CPU "
               "burst\n");
        exit(1);
    }

    // Otherwise, print out a line with my name, followed by the arguments on a line, then a trailing newline
    printf("Assignment 2 program was written by Andrew DiCarlo\n");
    for (i = 1; i < argc; i++) {
        if (i != 1) {
            printf(" ");
        }
        printf("%s", argv[i]);
        // convert current argument to pass to schedulers
        // If atoi fails, it returns 0, which does not work for our purposes
        *(argAdds[i - 1]) = atoi(argv[i]);
    }
    printf("\n");
    for (i = 0; i < argc - 1; i++) {
        if (*(argAdds[i]) <= 0) {
            printf("Bad argument '%d': arguments must be greater than 0\n", *(argAdds[i]));
            exit(1);
        }
    }

    // Allocate enough space for both processes to run all of their processes one after the other. This should avoid
    // running out of buffer space during any single scheduler
    int buffLen = (x1 + x2 + y1 + y2 + z1 + z2 + 1);
    char *ps1 = (char *)malloc(sizeof(char) * buffLen);
    char *ps2 = (char *)malloc(sizeof(char) * buffLen);

    // Init both buffers to all null
    memset(ps1, 0, buffLen);
    memset(ps2, 0, buffLen);

    fcfs(ps1, ps2, x1, y1, z1, x2, y2, z2);
    printSchedOutput(ps1, ps2, "fcfs");

    // Reset both buffers to all null
    memset(ps1, 0, buffLen);
    memset(ps2, 0, buffLen);

    sjf(ps1, ps2, x1, y1, z1, x2, y2, z2);
    printSchedOutput(ps1, ps2, "sjf");

    // Reset both buffers to all null
    memset(ps1, 0, buffLen);
    memset(ps2, 0, buffLen);

    psjf(ps1, ps2, x1, y1, z1, x2, y2, z2);
    printSchedOutput(ps1, ps2, "psjf");

    // Reset both buffers to all null
    memset(ps1, 0, buffLen);
    memset(ps2, 0, buffLen);

    rr(ps1, ps2, q, x1, y1, z1, x2, y2, z2);
    printSchedOutput(ps1, ps2, "rr");

    free(ps1);
    free(ps2);
}

// Process and print the output for the scheduler output passed to it
void printSchedOutput(char *s1, char *s2, char *alg)
{
    // Initialize counters for various process states and final outputs
    int r1 = 0, r2 = 0, R1 = 0, R2 = 0, i;
    double wavg, cutil;

    // Count the time spent waiting and time spent working for s1
    for (i = 0; i < strlen(s1); i++) {
        if (s1[i] == 'r') {
            r1++;
        }
        else if (s1[i] == 'R') {
            R1++;
        }
    }
    // Count the time spent waiting and time spent working for s2
    for (i = 0; i < strlen(s2); i++) {
        if (s2[i] == 'r') {
            r2++;
        }
        else if (s2[i] == 'R') {
            R2++;
        }
    }

    // Calculate the average waiting time
    wavg = ((double)r1 + (double)r2) / 2;

    // Calculate the overall CPU utilization
    cutil = ((double)R1 + (double)R2) / MAX(strlen(s1), strlen(s2));

    // Print the scheduler used, the output strings generated by it, and the statistics for the algorithm
    printf("scheduler %s:\n", alg);
    printf("%s\n%s\n", s1, s2);
    printf("%d %d %.1f %.5f\n", r1, r2, wavg, cutil);
}
